<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced AI Call Simulator</title>
    <!-- Tailwind CSS CDN for utility-first styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <style>
        /* Custom CSS for a dark theme with smooth transitions and specific element styling */
        :root {
            --bg-main: #0a0a0a;
            --bg-container: #1a1a1a;
            --bg-message-ai: #2d2d2d;
            --bg-message-user: #1a6cd0;
            --text-main: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-color: #1a6cd0;
            --success-color: #10b981;
            --error-color: #ef4444;
            --quality-bg: #2d2d2d;
            --quality-border: #444;
            --quality-score-good: #10b981;
            --quality-score-bad: #ef4444;
            --quality-score-neutral: #f59e0b;
            color-scheme: dark;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-main);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem; /* Padding for mobile view */
            box-sizing: border-box;
        }

        /* Responsive container sizing */
        #app-container {
            background-color: var(--bg-container);
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column; /* Stack vertically on smaller screens */
            width: 100%;
            max-width: 90%; /* Max width for desktop */
            height: 90vh; /* Responsive height */
            overflow: hidden;
            transition: all 0.3s ease-in-out;
        }

        @media (min-width: 768px) {
            #app-container {
                flex-direction: row; /* Side-by-side on larger screens */
                max-width: 1200px;
                height: 85vh;
            }
        }

        .chat-section {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            overflow: hidden; /* Important for chat scrolling */
            border-radius: 1rem; /* Rounded corners */
        }

        .messages {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 0.5rem; /* Space for scrollbar */
            margin-bottom: 1rem;
            scroll-behavior: smooth;
        }

        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 85%;
            word-wrap: break-word; /* Ensure long words break */
        }

        .message.user {
            background-color: var(--bg-message-user);
            margin-left: auto;
            color: var(--text-main);
        }

        .message.ai {
            background-color: var(--bg-message-ai);
            margin-right: auto;
            color: var(--text-main);
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-btn {
            background-color: var(--accent-color);
            color: var(--text-main);
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            flex-grow: 1; /* Allow buttons to grow */
        }

        .control-btn:hover:not(:disabled) {
            background-color: #155bb3; /* Darker shade of accent */
            transform: translateY(-2px);
        }

        .control-btn:disabled {
            background-color: #4a4a4a;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .status-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            text-align: center;
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Quality Feedback Panel Styling */
        .quality-panel {
            background-color: var(--quality-bg);
            border-left: 1px solid var(--quality-border);
            padding: 1.5rem;
            width: 100%; /* Full width on small screens */
            max-height: 50%; /* Limit height on small screens */
            overflow-y: auto;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .quality-panel {
                width: 350px; /* Fixed width on larger screens */
                min-width: 300px; /* Ensures it doesn't shrink too much */
                max-height: 100%; /* Full height */
            }
        }

        .quality-panel h3 {
            color: var(--text-main);
            font-size: 1.25rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .quality-score {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
        }

        .score-good { color: var(--quality-score-good); }
        .score-bad { color: var(--quality-score-bad); }
        .score-neutral { color: var(--quality-score-neutral); }

        .quality-comment {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            padding: 1rem;
            font-size: 0.95rem;
            line-height: 1.4;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .quality-section-summary {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .quality-section-item {
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .quality-section-item span:first-child {
            font-weight: 500;
            color: var(--text-main);
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-container);
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal.show .modal-content {
            transform: translateY(0);
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s;
        }

        .modal-close-btn:hover {
            color: var(--text-main);
        }

        .modal-body h4 {
            font-size: 1.1rem;
            color: var(--text-main);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .modal-body ul {
            list-style: none;
            padding: 0;
            margin-bottom: 1rem;
        }

        .modal-body ul li {
            background-color: rgba(255, 255, 255, 0.03);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 0.4rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body ul li span:first-child {
            flex-grow: 1;
            font-weight: 500;
        }

        .modal-body .total-score {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-color);
            text-align: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .export-button {
            background-color: var(--accent-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s ease-in-out;
            display: block;
            width: fit-content;
            margin: 1.5rem auto 0;
        }

        .export-button:hover {
            background-color: #155bb3;
        }

        .user-id-display {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            word-break: break-all;
        }
    </style>
</head>
<body class="antialiased">
    <div id="app-container" class="flex flex-col md:flex-row bg-gray-900 rounded-2xl shadow-xl overflow-hidden">
        <!-- Chat Section -->
        <div class="chat-section flex flex-col flex-grow p-6 md:p-8">
            <h2 class="text-2xl md:text-3xl font-bold text-white mb-4 text-center">AI Call Simulator</h2>
            <div id="chat" class="messages flex-grow overflow-y-auto pr-2 mb-4 rounded-lg">
                <!-- Messages will be appended here -->
            </div>
            <div class="user-id-display" id="user-id-display">
                Loading User ID...
            </div>
            <div class="status-text text-gray-400 text-sm mt-2 mb-4 text-center" id="status">
                Initializing...
            </div>
            <div class="loader" id="loader"></div>
            <div class="controls flex gap-3 pt-4 border-t border-gray-700">
                <button id="mic-btn" class="control-btn bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-5 rounded-xl flex-grow disabled:bg-gray-700">
                    <i class="fas fa-microphone"></i> <span id="mic-btn-text">Start Mic</span>
                </button>
                <button id="send-btn" class="control-btn bg-green-600 hover:bg-green-700 text-white font-medium py-3 px-5 rounded-xl flex-grow disabled:bg-gray-700" disabled>
                    <i class="fas fa-paper-plane"></i> Send
                </button>
                <button id="cancel-btn" class="control-btn bg-red-600 hover:bg-red-700 text-white font-medium py-3 px-5 rounded-xl flex-grow disabled:bg-gray-700" disabled>
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button id="mute-btn" class="control-btn bg-purple-600 hover:bg-purple-700 text-white font-medium py-3 px-5 rounded-xl flex-grow-0 w-12 disabled:bg-gray-700">
                    <i class="fas fa-volume-up" id="mute-icon"></i>
                </button>
            </div>
        </div>

        <!-- Quality Feedback Panel -->
        <div id="quality-feedback-panel" class="quality-panel bg-gray-800 p-6 md:p-8 flex flex-col">
            <h3 class="text-xl md:text-2xl font-semibold text-white mb-4 text-center">Live Quality Coach</h3>
            <div class="quality-score text-green-500 mb-4" id="quality-score">0</div>
            <div class="quality-comment bg-gray-700 rounded-lg p-4 text-gray-300 text-sm mb-4" id="quality-comment">
                No feedback yet. Agent responses will be evaluated here.
            </div>
            <div class="quality-section-summary text-sm flex-grow overflow-y-auto pr-2">
                <h4 class="text-md font-medium text-white mb-2">Section Scores:</h4>
                <div id="section-scores">
                    <!-- Section scores will be displayed here dynamically -->
                    <div class="quality-section-item"><span>S1: Start</span><span id="s1-score">N/A</span></div>
                    <div class="quality-section-item"><span>S2: Solve</span><span id="s2-score">N/A</span></div>
                    <div class="quality-section-item"><span>S3: Sell</span><span id="s3-score">N/A</span></div>
                    <div class="quality-section-item"><span>S4: Summarize</span><span id="s4-score">N/A</span></div>
                    <div class="quality-section-item"><span>Behaviors</span><span id="behaviors-score">N/A</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Post-Call Summary Modal -->
    <div id="post-call-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" id="modal-close-btn">&times;</button>
            <h3 class="text-2xl font-bold text-white mb-4 text-center">Call Summary Report</h3>
            <div class="modal-body">
                <div class="auto-fail-status mb-4 text-center" id="auto-fail-status" style="display: none;">
                    <p class="text-red-500 font-bold text-lg"><i class="fas fa-exclamation-triangle"></i> AUTO-FAIL DETECTED!</p>
                    <p class="text-red-400 text-sm" id="auto-fail-reason"></p>
                </div>

                <div class="section-details" id="modal-section-details">
                    <!-- Detailed section breakdown will be populated here -->
                </div>

                <div class="total-score" id="modal-total-score">
                    Overall Score: <span class="text-blue-500">0</span> / 100
                </div>

                <button id="export-report-btn" class="export-button bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-6 rounded-xl mt-6">
                    Export Report (JSON)
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, getDocs, onSnapshot, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Constants for Gemini API and Quality Guidelines
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=`; // API key left empty as per instructions
        const IMAGE_GENERATION_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=`; // For future image generation, if needed

        // SCORING_GUIDELINES_SUMMARY content moved here from s4_guidelines.html
        const SCORING_GUIDELINES_SUMMARY = `
You are an expert Comcast Quality Assurance specialist. Your task is to analyze a given call transcript and score the agent's performance strictly according to the Comcast S4 Quality Training Material guidelines.

Here are the scoring guidelines for each section (ME = Meets Expectations, HE = Highly Effective, BE = Below Expectations, N/A = Not Applicable):

S1: START (Max 22 points)
- 1. Greeting (Max 3 points): Agent greets clearly (Comcast Name, Agent First Name, offer assistance). BE=0 if incomplete/rushed.
- 2. Reflect, Relate, Empathize (Max 15 points): Reflects call reason, empathizes with customer, assures action. BE=0 if vague, uses "trap" words, no ownership.
- 3. Set Agenda / Auth / Plant Seed (Max 4 points): Sets agenda, authenticates caller, "plants seed" for account review (HE=4, ME=2). BE=0 if fails any.

S2: SOLVE (Max 27 points)
- 4. Obtain Info / Probe (Max 7 points): Asks effective questions, probes root causes (HE=7, ME=4). BE=0 if makes assumptions, no opportunity for customer to describe problem.
- 5. Resolve / Address Issue(s) (Max 14 points): Explains problem cause, provides complete resolution, educates on prevention, resolves underlying issues (HE=14, ME=7). BE=0 if incomplete, insufficient info, no confirmation.
- 6. Build Value / Enhance (Max 6 points): Attempts email capture AND builds value of EXISTING Comcast products/services/company. BE=0 if fails any.

S3: SELL (Max 20 points) - ONLY APPLICABLE IF CUSTOMER IS NOT IRATE, AUTHENTICATED, AND HASN'T OPTED OUT OF SALES.
- 7. Transition to Relevant Offer (Max 6 points): Transitions after resolving issue, uses bridging statements, probes for needs (HE=6, ME=3). BE=0 if transitions too early, no bridging.
- 8. Present Offer (Max 6 points): Presents tailored recommendation, discusses benefits/value (HE=6, ME=3). BE=0 if only price, no benefits.
- 9. Overcome Objections (Max 4 points): Acknowledges objection, attempts to overcome resistance (HE=4, ME=2). BE=0 if poor attempt, aggressive. N/A if customer accepts without resistance.
- 10. Proactively Ask for the Sale (Max 4 points): Uses closing techniques (e.g., choice, assumptive, urgency) (ME=4). BE=0 if discusses solution but doesn't ask. N/A if customer pre-purchases or rejects after objection handling.

S4: SUMMARIZE (Max 14 points)
- 11. Summarize Actions (Max 7 points): Provides clear next steps, documents resolution, validates sales (ME=7). BE=0 if no recap or next steps.
- 12. Close Contact (Max 4 points): Offers additional assistance, personalized closing, shows appreciation (ME=4). BE=0 if fails any.
- 13. Documentation (Max 3 points): Documents caller, reason, resolution/actions (ME=3). BE=0 if missing required info. (Cannot be fully assessed from transcript alone).

Behaviors (Max 17 points) - Assessed throughout the call:
- Tone, Confidence & Clarity (Max 3 points): Professional, pleasant, clear, unrushed pace. BE=0 if fails.
- Active Listening (Max 3 points): Verbal cues, avoids interruption, references customer info. BE=0 if fails.
- Contact Management (Max 3 points): Minimizes dead air (<20s), manages holds (<60s) with explanation. BE=0 if fails.
- Acknowledge / Take Responsibility (Max 4 points): Assures solution, positive language, avoids blame. BE=0 if fails.
- Build Rapport / Demonstrate Concern (Max 4 points): Genuine interest, acknowledges feelings, personalizes interaction. BE=0 if fails.

Critical Failure Policies:
- Section Failures (Deduct points from specific section):
    - Authentication (S1 Failure): Disclosing info to non-authorized user. Deducts all 22 points from S1.
    - Account Actions (S2 Failure): Misinforming about charges, failing promises, not escalating supervisor call. Deducts all 27 points from S2.
    - TPV Process (S4 Failure): Failure to attempt Third Party Verification where required. Deducts all 14 points from S4.
- Auto-Fail Behaviors (Results in 0 overall score for the entire call):
    - Rudeness (verbal): Rude, disrespectful, arguing, profanity, hanging up, refusing escalation/transfer.
    - Call Avoidance: Failing to answer, personal calls/web surfing.
    - Inappropriate Transfer: Blind transfer, advocating for customers to contact other departments.

Return a JSON object with the following structure. Strictly adhere to this JSON format for parsing.
{
  "autoFailDetected": boolean,
  "autoFailReason": "string (if auto-fail, otherwise empty)",
  "sections": {
    "s1": { "score": number, "max": number, "criteria": [ { "name": string, "awardedScore": number|string, "maxScore": number|string, "justification": string } ] },
    "s2": { "score": number, "max": number, "criteria": [ { "name": string, "awardedScore": number|string, "maxScore": number|string, "justification": string } ] },
    "s3": { "score": number, "max": number, "criteria": [ { "name": string, "awardedScore": number|string, "maxScore": number|string, "justification": string } ] },
    "s4": { "score": number, "max": number, "criteria": [ { "name": string, "awardedScore": number|string, "maxScore": number|string, "justification": string } ] },
    "behaviors": { "score": number, "max": number, "criteria": [ { "name": string, "awardedScore": number|string, "maxScore": number|string, "justification": string } ] }
  }
}
        `;

        /**
         * @class SpeechService
         * @description Manages speech synthesis (Text-to-Speech) for the application.
         * Handles loading voices, speaking text, and stopping speech.
         */
        class SpeechService {
            constructor() {
                if (!window.speechSynthesis) {
                    console.error('Speech synthesis not supported');
                    return;
                }

                this.synthesis = window.speechSynthesis;
                this.voices = [];
                this.isSpeaking = false;
                this.volume = 0.8; // Default volume
                this.defaultVoice = null;

                // Load voices immediately and set up a listener for when voices change (e.g., in Chrome)
                this.loadVoices();
                if (window.speechSynthesis.onvoiceschanged !== undefined) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        this.loadVoices();
                    };
                }
            }

            /**
             * Attempts to load available speech synthesis voices. Retries if no voices are found initially.
             * @param {number} retryCount - Number of retries.
             * @returns {Promise<SpeechSynthesisVoice[]>} A promise that resolves with the list of voices.
             */
            async loadVoices(retryCount = 5) {
                return new Promise((resolve, reject) => {
                    const attemptLoad = (attempts) => {
                        this.voices = this.synthesis.getVoices();
                        console.log(`[SpeechService] Attempt ${6 - attempts}: Found ${this.voices.length} voices`);

                        if (this.voices.length > 0) {
                            // Prioritize a US English voice if available, otherwise pick the first English voice
                            this.defaultVoice = this.voices.find(voice => voice.lang === 'en-US') ||
                                                this.voices.find(voice => voice.lang.startsWith('en')) ||
                                                this.voices[0]; // Fallback to any voice

                            console.log('[SpeechService] Available voices:', this.voices.map(v => `${v.name} (${v.lang})`));
                            console.log('[SpeechService] Default voice selected:', this.defaultVoice?.name);
                            resolve(this.voices);
                        } else if (attempts > 1) {
                            console.log('[SpeechService] No voices found, retrying...');
                            setTimeout(() => attemptLoad(attempts - 1), 100);
                        } else {
                            console.error('[SpeechService] Failed to load voices after multiple attempts');
                            reject(new Error('No voices found for speech synthesis.'));
                        }
                    };
                    attemptLoad(retryCount);
                });
            }

            /**
             * Speaks the given text using the selected voice.
             * @param {string} text - The text to speak.
             * @returns {Promise<void>} A promise that resolves when speech ends, or rejects on error.
             */
            async speak(text) {
                if (!this.synthesis || !this.defaultVoice || !text) {
                    console.warn('[SpeechService] Speech synthesis not ready or no text provided.', { synthesis: this.synthesis, defaultVoice: this.defaultVoice, text });
                    return Promise.resolve(); // Resolve silently if cannot speak
                }

                if (this.isSpeaking) {
                    this.stop(); // Stop any ongoing speech
                }

                return new Promise((resolve, reject) => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.voice = this.defaultVoice;
                    utterance.volume = this.volume;
                    utterance.pitch = 1.0;
                    utterance.rate = 0.9; // Slightly slower for better clarity

                    console.log('[SpeechService] Speaking:', {
                        text: text.substring(0, Math.min(text.length, 50)) + (text.length > 50 ? '...' : ''),
                        voice: this.defaultVoice.name,
                        volume: this.volume,
                        lang: utterance.lang
                    });

                    this.isSpeaking = true;

                    utterance.onstart = () => {
                        console.log('[SpeechService] Speech started');
                    };

                    utterance.onend = () => {
                        console.log('[SpeechService] Speech ended');
                        this.isSpeaking = false;
                        resolve();
                    };

                    utterance.onerror = (err) => {
                        console.error('[SpeechService] Speech error:', err);
                        this.isSpeaking = false;
                        reject(err);
                    };

                    // Small delay to ensure proper initialization and prevent errors on rapid calls
                    setTimeout(() => {
                        try {
                            this.synthesis.speak(utterance);
                        } catch (error) {
                            console.error('[SpeechService] Error initiating speech:', error);
                            this.isSpeaking = false;
                            reject(error);
                        }
                    }, 100);
                });
            }

            /**
             * Stops any ongoing speech synthesis.
             */
            stop() {
                if (this.synthesis) {
                    this.synthesis.cancel();
                    this.isSpeaking = false;
                    console.log('[SpeechService] Speech cancelled');
                }
            }
        }


        /**
         * @class ComplaintsService
         * @description Handles communication with the Gemini API for customer responses and quality feedback.
         * Manages chat history and constructs prompts for LLM.
         */
        class ComplaintsService {
            constructor() {
                // API_KEY is intentionally left empty as per instructions. Canvas will provide it at runtime.
                this.API_KEY = "";
                this.GEMINI_API_URL = GEMINI_API_URL;

                this.customerPersona = "You are a Comcast customer with a billing inquiry. You are slightly frustrated but polite. Respond concisely.";
                this.qualityAssistantPersona = "You are an S4 Quality Assurance Specialist. Evaluate the agent's last response based on the S4 guidelines provided. Focus on Start, Solve, Sell, Summarize, and Foundational Behaviors.";
                this.chatHistory = []; // Stores the full conversation for LLM context
            }

            /**
             * Makes an API call to Gemini to get a customer's response based on the agent's message.
             * @param {string} agentMessage - The agent's last message.
             * @returns {Promise<string>} The customer's generated response.
             */
            async getCustomerResponse(agentMessage) {
                // Add the agent's message to history before sending to the LLM
                this.chatHistory.push({ role: "user", parts: [{ text: agentMessage }] });

                const customerPrompt = `Customer Persona: ${this.customerPersona}\n\nAgent: "${agentMessage}"\nCustomer:`;

                const payload = {
                    contents: this.chatHistory.concat([{
                        role: "user",
                        parts: [{ text: customerPrompt }]
                    }])
                };

                try {
                    const response = await fetch(this.GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API Error: ${response.statusText} - ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    const customerReply = data.candidates?.[0]?.content?.parts?.[0]?.text || '(No customer response)';

                    // Add the customer's reply to chat history
                    this.chatHistory.push({ role: "model", parts: [{ text: customerReply }] });

                    return customerReply;

                } catch (error) {
                    console.error("Gemini API Error (Customer Response):", error);
                    return `(Error: Could not get customer response - ${error.message})`;
                }
            }

            /**
             * Generates a quality feedback report from the LLM based on the full transcript.
             * @param {string} transcript - The complete conversation transcript.
             * @returns {Promise<object>} The parsed JSON quality report.
             */
            async getQualityFeedback(transcript) {
                const prompt = `${SCORING_GUIDELINES_SUMMARY}\n\nCall Transcript:\n\`\`\`\n${transcript}\n\`\`\``;
                let chatHistoryForQuality = [];
                chatHistoryForQuality.push({ role: "user", parts: [{ text: prompt }] });

                const payload = {
                    contents: chatHistoryForQuality,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "autoFailDetected": { "type": "BOOLEAN" },
                                "autoFailReason": { "type": "STRING" },
                                "totalScore": { "type": "NUMBER" }, // Added for overall score
                                "sections": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "s1": { "type": "OBJECT", "properties": { "score": { "type": "NUMBER" }, "max": { "type": "NUMBER" }, "criteria": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "name": { "type": "STRING" }, "awardedScore": { "type": ["NUMBER", "STRING"] }, "maxScore": { "type": ["NUMBER", "STRING"] }, "justification": { "type": "STRING" } } } } } },
                                        "s2": { "type": "OBJECT", "properties": { "score": { "type": "NUMBER" }, "max": { "type": "NUMBER" }, "criteria": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "name": { "type": "STRING" }, "awardedScore": { "type": ["NUMBER", "STRING"] }, "maxScore": { "type": ["NUMBER", "STRING"] }, "justification": { "type": "STRING" } } } } } },
                                        "s3": { "type": "OBJECT", "properties": { "score": { "type": "NUMBER" }, "max": { "type": "NUMBER" }, "criteria": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "name": { "type": "STRING" }, "awardedScore": { "type": ["NUMBER", "STRING"] }, "maxScore": { "type": ["NUMBER", "STRING"] }, "justification": { "type": "STRING" } } } } } },
                                        "s4": { "type": "OBJECT", "properties": { "score": { "type": "NUMBER" }, "max": { "type": "NUMBER" }, "criteria": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "name": { "type": "STRING" }, "awardedScore": { "type": ["NUMBER", "STRING"] }, "maxScore": { "type": ["NUMBER", "STRING"] }, "justification": { "type": "STRING" } } } } } },
                                        "behaviors": { "type": "OBJECT", "properties": { "score": { "type": "NUMBER" }, "max": { "type": "NUMBER" }, "criteria": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "name": { "type": "STRING" }, "awardedScore": { "type": ["NUMBER", "STRING"] }, "maxScore": { "type": ["NUMBER", "STRING"] }, "justification": { "type": "STRING" } } } } } }
                                    }
                                }
                            }
                        }
                    }
                };

                try {
                    const response = await fetch(this.GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API Error: ${response.statusText} - ${JSON.stringify(errorData)}`);
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {

                        const jsonString = result.candidates[0].content.parts[0].text;
                        const parsedResults = JSON.parse(jsonString);

                        // Calculate total score if not provided by LLM (though schema asks for it now)
                        if (typeof parsedResults.totalScore === 'undefined') {
                            let totalScore = 0;
                            if (!parsedResults.autoFailDetected && parsedResults.sections) {
                                totalScore += parsedResults.sections.s1?.score || 0;
                                totalScore += parsedResults.sections.s2?.score || 0;
                                totalScore += parsedResults.sections.s3?.score || 0;
                                totalScore += parsedResults.sections.s4?.score || 0;
                                totalScore += parsedResults.sections.behaviors?.score || 0;
                            }
                            parsedResults.totalScore = totalScore;
                        }

                        return parsedResults;

                    } else {
                        console.error('LLM response structure unexpected:', result);
                        return {
                            autoFailDetected: false,
                            autoFailReason: 'LLM returned no content or malformed content.',
                            totalScore: 0,
                            sections: {},
                            comment: "No detailed quality feedback received."
                        };
                    }
                } catch (error) {
                    console.error('Error scoring call with LLM:', error);
                    return {
                        autoFailDetected: false,
                        autoFailReason: `API call failed: ${error.message}`,
                        totalScore: 0,
                        sections: {},
                        comment: `Error: Could not get quality feedback - ${error.message}`
                    };
                }
            }

            /**
             * Clears the internal chat history.
             */
            clearHistory() {
                this.chatHistory = [];
            }

            /**
             * Provides the initial customer scenario.
             * @returns {string} The initial customer statement.
             */
            getInitialScenario() {
                return "Hello, I'm calling about my internet service.";
            }
        }


        /**
         * @class CallSimulator
         * @description Main application logic for the call simulator.
         * Manages UI, speech recognition, chat flow, and integration with services.
         */
        class CallSimulator {
            constructor() {
                this.speechService = new SpeechService();
                this.complaintsService = new ComplaintsService();

                // Firebase properties
                this.firebaseApp = null;
                this.db = null;
                this.auth = null;
                this.userId = 'anonymous'; // Default to anonymous
                this.isAuthReady = false; // Flag to indicate if auth state is determined

                this.bindElements();
                this.initializeState();
                this.addEventListeners();
                this.setupFirebase(); // Initialize Firebase
            }

            /**
             * Binds DOM elements to class properties for easy access.
             */
            bindElements() {
                this.micBtn = document.getElementById('mic-btn');
                this.micBtnText = document.getElementById('mic-btn-text');
                this.sendBtn = document.getElementById('send-btn');
                this.cancelBtn = document.getElementById('cancel-btn');
                this.muteBtn = document.getElementById('mute-btn');
                this.muteIcon = document.getElementById('mute-icon');
                this.chatDiv = document.getElementById('chat'); // Renamed from this.chat to avoid conflict with chat history
                this.statusDiv = document.getElementById('status');
                this.loaderDiv = document.getElementById('loader');
                this.qualityFeedbackPanel = document.getElementById('quality-feedback-panel');
                this.qualityScoreDisplay = document.getElementById('quality-score');
                this.qualityCommentDisplay = document.getElementById('quality-comment');
                this.sectionScoresDisplay = document.getElementById('section-scores');
                this.userIdDisplay = document.getElementById('user-id-display');

                // Modal elements
                this.postCallModal = document.getElementById('post-call-modal');
                this.modalCloseBtn = document.getElementById('modal-close-btn');
                this.modalSectionDetails = document.getElementById('modal-section-details');
                this.modalTotalScore = document.getElementById('modal-total-score');
                this.exportReportBtn = document.getElementById('export-report-btn');
                this.autoFailStatus = document.getElementById('auto-fail-status');
                this.autoFailReason = document.getElementById('auto-fail-reason');
            }

            /**
             * Initializes the application's state variables.
             */
            initializeState() {
                this.recognition = null;
                this.isRecognizing = false;
                this.currentTranscript = '';
                this.silenceTimer = null;
                this.isMuted = false;
                this.autoSendDelay = 2000; // 2 seconds of silence before auto-send
                this.fullTranscript = []; // Stores {speaker: 'user'/'ai', text: 'message'} for full call quality assessment
                this.latestQualityReport = null; // Stores the last received quality report
            }

            /**
             * Sets up Firebase authentication and Firestore.
             */
            async setupFirebase() {
                if (firebaseConfig) {
                    this.firebaseApp = initializeApp(firebaseConfig);
                    this.db = getFirestore(this.firebaseApp);
                    this.auth = getAuth(this.firebaseApp);

                    onAuthStateChanged(this.auth, async (user) => {
                        if (user) {
                            this.userId = user.uid;
                            console.log('Firebase: User signed in:', this.userId);
                        } else {
                            // Sign in anonymously if no token is provided or user logs out
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(this.auth, initialAuthToken);
                                } else {
                                    await signInAnonymously(this.auth);
                                }
                                this.userId = this.auth.currentUser?.uid || crypto.randomUUID(); // Fallback if anonymous fails
                                console.log('Firebase: Signed in anonymously or with custom token:', this.userId);
                            } catch (error) {
                                console.error('Firebase: Anonymous sign-in failed:', error);
                                // Generate a random ID if Firebase auth fails completely
                                this.userId = crypto.randomUUID();
                                this.addMessage(`Error: Could not authenticate with Firebase. Functionality may be limited. User ID: ${this.userId}`, 'ai');
                            }
                        }
                        this.isAuthReady = true;
                        this.userIdDisplay.textContent = `Your Session ID: ${this.userId}`;
                        console.log('Firebase: Auth state ready, loading history...');
                        this.loadChatHistoryFromFirestore();
                    });
                } else {
                    console.error('Firebase config not found. Running without persistence.');
                    this.isAuthReady = true; // Still allow app to run
                    this.userId = crypto.randomUUID();
                    this.userIdDisplay.textContent = `Your Session ID: ${this.userId} (No Persistence)`;
                }
            }

            /**
             * Adds event listeners to control buttons.
             */
            addEventListeners() {
                this.micBtn.addEventListener('click', () => this.toggleRecognition());
                this.sendBtn.addEventListener('click', () => this.handleSendClick());
                this.cancelBtn.addEventListener('click', () => this.handleCancelClick());
                this.muteBtn.addEventListener('click', () => this.toggleMute());
                this.modalCloseBtn.addEventListener('click', () => this.postCallModal.classList.remove('show'));
                this.exportReportBtn.addEventListener('click', () => this.exportQualityReport());
            }

            /**
             * Updates the status message displayed in the UI.
             * @param {string} message - The status message to display.
             * @param {boolean} showLoader - Whether to show or hide the loading spinner.
             */
            updateStatus(message, showLoader) {
                this.statusDiv.textContent = message;
                this.loaderDiv.style.display = showLoader ? 'block' : 'none';
                // Update button states based on recognition state
                this.micBtn.disabled = showLoader; // Disable mic during processing
                this.sendBtn.disabled = showLoader || !this.currentTranscript.trim();
                this.cancelBtn.disabled = showLoader;
                this.muteBtn.disabled = showLoader;
            }

            /**
             * Displays a new message in the chat interface.
             * @param {string} text - The message text.
             * @param {'user' | 'ai'} sender - The sender of the message ('user' or 'ai').
             */
            addMessage(text, sender) {
                const div = document.createElement('div');
                div.className = `message ${sender}`;
                div.textContent = text;
                this.chatDiv.appendChild(div);
                this.chatDiv.scrollTop = this.chatDiv.scrollHeight; // Scroll to bottom
            }

            /**
             * Saves a chat message to Firestore.
             * @param {string} text - The message text.
             * @param {'user' | 'ai'} sender - The sender of the message ('user' or 'ai').
             */
            async saveMessageToFirestore(text, sender) {
                if (!this.db || !this.isAuthReady) {
                    console.warn('Firestore not ready, skipping save message.');
                    return;
                }
                try {
                    await addDoc(collection(this.db, `artifacts/${appId}/users/${this.userId}/chats`), {
                        text,
                        sender,
                        timestamp: serverTimestamp(),
                        appId: appId,
                        userId: this.userId
                    });
                } catch (e) {
                    console.error("Error adding document to Firestore: ", e);
                }
            }

            /**
             * Loads chat history from Firestore and displays it.
             */
            async loadChatHistoryFromFirestore() {
                if (!this.db || !this.isAuthReady) {
                    console.warn('Firestore not ready, skipping load message.');
                    return;
                }
                this.chatDiv.innerHTML = ''; // Clear existing messages
                this.fullTranscript = []; // Clear transcript for fresh load

                const q = query(collection(this.db, `artifacts/${appId}/users/${this.userId}/chats`), orderBy('timestamp'));
                onSnapshot(q, (snapshot) => {
                    this.chatDiv.innerHTML = ''; // Clear on every update to re-render
                    this.fullTranscript = [];
                    snapshot.forEach((doc) => {
                        const data = doc.data();
                        this.addMessage(data.text, data.sender);
                        this.fullTranscript.push({ speaker: data.sender, text: data.text });
                    });
                    this.chatDiv.scrollTop = this.chatDiv.scrollHeight;
                }, (error) => {
                    console.error("Error listening to chat history: ", error);
                    this.addMessage('Error loading chat history.', 'ai');
                });
            }

            /**
             * Saves a quality feedback report to Firestore.
             * @param {object} feedback - The quality feedback object.
             */
            async saveQualityFeedbackToFirestore(feedback) {
                if (!this.db || !this.isAuthReady) {
                    console.warn('Firestore not ready, skipping save quality feedback.');
                    return;
                }
                try {
                    await addDoc(collection(this.db, `artifacts/${appId}/users/${this.userId}/qualityFeedback`), {
                        report: feedback,
                        timestamp: serverTimestamp(),
                        appId: appId,
                        userId: this.userId,
                        transcript: this.fullTranscript.map(m => `${m.speaker === 'user' ? 'Agent' : 'Customer'}: ${m.text}`).join('\n') // Save the full transcript for context
                    });
                    console.log('Quality feedback saved to Firestore.');
                } catch (e) {
                    console.error("Error adding quality feedback to Firestore: ", e);
                }
            }

            /**
             * Initializes speech recognition (if supported by browser).
             */
            initRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    this.updateStatus('Speech recognition not supported in this browser.', false);
                    this.micBtn.disabled = true;
                    return;
                }

                this.recognition = new SpeechRecognition();
                this.recognition.continuous = false; // Process one utterance at a time
                this.recognition.interimResults = true; // Get interim results to show live transcript
                this.recognition.lang = 'en-US';

                this.recognition.onstart = () => {
                    this.isRecognizing = true;
                    this.micBtnText.textContent = 'Stop Mic';
                    this.updateStatus('Listening...', true);
                    this.sendBtn.disabled = true; // Disable send until speech detected
                    this.cancelBtn.disabled = false;
                    clearTimeout(this.silenceTimer);
                };

                this.recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcriptPart = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcriptPart;
                        } else {
                            interimTranscript += transcriptPart;
                        }
                    }
                    this.currentTranscript = finalTranscript || interimTranscript;

                    // Update the last user message or create a new one for interim results
                    const messages = this.chatDiv.querySelector('.messages');
                    let lastMessage = messages.lastElementChild;

                    if (lastMessage && lastMessage.classList.contains('user') && !lastMessage.classList.contains('sent')) {
                        lastMessage.textContent = `(You): ${this.currentTranscript}`;
                    } else {
                        // Create a temporary message if it's the first bit of speech
                        this.addMessage(`(You): ${this.currentTranscript}`, 'user');
                        lastMessage = messages.lastElementChild;
                    }

                    // Mark as sent if it's a final transcript
                    if (finalTranscript) {
                        lastMessage.classList.add('sent');
                        this.sendBtn.disabled = false; // Enable send button on final transcript
                        clearTimeout(this.silenceTimer);
                        this.silenceTimer = setTimeout(() => {
                            this.handleSendClick(); // Auto-send after silence
                        }, this.autoSendDelay);
                    }
                    this.chatDiv.scrollTop = this.chatDiv.scrollHeight; // Scroll to bottom
                };

                this.recognition.onend = () => {
                    this.isRecognizing = false;
                    this.micBtnText.textContent = 'Start Mic';
                    this.updateStatus('Click mic to start', false);
                    clearTimeout(this.silenceTimer);
                    // If no final transcript was sent, allow send button if currentTranscript has content
                    this.sendBtn.disabled = !this.currentTranscript.trim();
                    this.cancelBtn.disabled = true; // Disable cancel if recognition has ended
                };

                this.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    this.isRecognizing = false;
                    this.micBtnText.textContent = 'Start Mic';
                    this.updateStatus(`Error: ${event.error}. Click mic to retry.`, false);
                    this.micBtn.disabled = false;
                    this.sendBtn.disabled = true;
                    this.cancelBtn.disabled = true;
                    clearTimeout(this.silenceTimer);
                };
            }

            /**
             * Toggles speech recognition on/off.
             */
            toggleRecognition() {
                if (this.isRecognizing) {
                    this.recognition.stop();
                } else {
                    this.currentTranscript = ''; // Clear previous transcript
                    // Remove any unsent temporary user message
                    const messages = this.chatDiv.querySelector('.messages');
                    const lastMessage = messages.lastElementChild;
                    if (lastMessage && lastMessage.classList.contains('user') && !lastMessage.classList.contains('sent')) {
                        lastMessage.remove();
                    }
                    this.recognition.start();
                }
            }

            /**
             * Handles sending the user's message (agent's response).
             */
            async handleSendClick() {
                const agentMessage = this.currentTranscript.trim();
                if (!agentMessage) return;

                this.recognition.stop(); // Ensure recognition is stopped
                this.updateStatus('Sending message...', true);
                this.sendBtn.disabled = true;
                this.cancelBtn.disabled = true;

                // Ensure the final user message is marked as sent and displayed correctly
                const messages = this.chatDiv.querySelector('.messages');
                let lastMessage = messages.lastElementChild;
                if (lastMessage && lastMessage.classList.contains('user') && !lastMessage.classList.contains('sent')) {
                    lastMessage.textContent = `You: ${agentMessage}`;
                    lastMessage.classList.add('sent');
                } else {
                    this.addMessage(`You: ${agentMessage}`, 'user');
                }
                this.fullTranscript.push({ speaker: 'user', text: agentMessage }); // Add to full transcript
                await this.saveMessageToFirestore(agentMessage, 'user'); // Save to Firestore

                this.currentTranscript = ''; // Clear transcript for next input

                try {
                    // Get customer response
                    const customerResponse = await this.complaintsService.getCustomerResponse(agentMessage);
                    this.addMessage(`Customer: ${customerResponse}`, 'ai');
                    this.fullTranscript.push({ speaker: 'ai', text: customerResponse }); // Add to full transcript
                    await this.saveMessageToFirestore(customerResponse, 'ai'); // Save to Firestore

                    if (!this.isMuted) {
                        this.updateStatus('Speaking...', true);
                        await this.speechService.speak(customerResponse);
                    }

                    // Get and display quality feedback after customer response
                    this.updateStatus('Analyzing quality...', true);
                    const currentTranscriptText = this.fullTranscript.map(m => {
                        const speakerPrefix = m.speaker === 'user' ? 'Agent' : 'Customer';
                        return `${speakerPrefix}: ${m.text}`;
                    }).join('\n');

                    this.latestQualityReport = await this.complaintsService.getQualityFeedback(currentTranscriptText);
                    this.displayQualityFeedback(this.latestQualityReport);
                    await this.saveQualityFeedbackToFirestore(this.latestQualityReport); // Save quality report to Firestore

                } catch (error) {
                    console.error('Error during message processing:', error);
                    this.addMessage(`System Error: ${error.message}`, 'ai');
                } finally {
                    this.updateStatus('Click mic to start', false);
                    this.micBtn.disabled = false;
                    this.sendBtn.disabled = true;
                    this.cancelBtn.disabled = false; // Allow cancel if user wants to clear partial transcript
                }
            }

            /**
             * Handles the cancel button click, clearing the current transcript.
             */
            handleCancelClick() {
                this.currentTranscript = '';
                this.recognition.stop(); // Stop recognition
                // Remove any unsent user message from display
                const messages = this.chatDiv.querySelector('.messages');
                const lastMessage = messages.lastElementChild;
                if (lastMessage && lastMessage.classList.contains('user') && !lastMessage.classList.contains('sent')) {
                    lastMessage.remove();
                }
                this.updateStatus('Click mic to start', false);
                this.sendBtn.disabled = true;
            }

            /**
             * Toggles the mute state for speech output.
             */
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.isMuted) {
                    this.speechService.stop(); // Stop any ongoing speech
                    this.muteIcon.classList.replace('fa-volume-up', 'fa-volume-mute');
                    this.muteBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                    this.muteBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                } else {
                    this.muteIcon.classList.replace('fa-volume-mute', 'fa-volume-up');
                    this.muteBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                    this.muteBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                }
                console.log('Mute status:', this.isMuted);
            }

            /**
             * Displays the quality feedback in the dedicated panel.
             * @param {object} report - The quality report object.
             */
            displayQualityFeedback(report) {
                if (!report) {
                    this.qualityScoreDisplay.textContent = 'N/A';
                    this.qualityCommentDisplay.textContent = 'No detailed report available.';
                    this.qualityScoreDisplay.className = 'quality-score score-neutral';
                    this.sectionScoresDisplay.innerHTML = `
                        <div class="quality-section-item"><span>S1: Start</span><span>N/A</span></div>
                        <div class="quality-section-item"><span>S2: Solve</span><span>N/A</span></div>
                        <div class="quality-section-item"><span>S3: Sell</span><span>N/A</span></div>
                        <div class="quality-section-item"><span>S4: Summarize</span><span>N/A</span></div>
                        <div class="quality-section-item"><span>Behaviors</span><span>N/A</span></div>
                    `;
                    return;
                }

                this.qualityScoreDisplay.textContent = report.totalScore;
                if (report.autoFailDetected) {
                    this.qualityScoreDisplay.className = 'quality-score score-bad';
                    this.qualityCommentDisplay.innerHTML = `<span class="font-bold text-red-400">Auto-Fail:</span> ${report.autoFailReason || 'Reason not specified.'}`;
                } else {
                    if (report.totalScore >= 80) {
                        this.qualityScoreDisplay.className = 'quality-score score-good';
                    } else if (report.totalScore >= 50) {
                        this.qualityScoreDisplay.className = 'quality-score score-neutral';
                    } else {
                        this.qualityScoreDisplay.className = 'quality-score score-bad';
                    }
                    this.qualityCommentDisplay.textContent = report.comment || 'Overall performance feedback.'; // Assuming comment property exists
                }

                // Update section scores
                const sections = report.sections;
                this.sectionScoresDisplay.innerHTML = ''; // Clear previous scores
                for (const key in sections) {
                    if (sections.hasOwnProperty(key)) {
                        const section = sections[key];
                        const sectionName = key.charAt(0).toUpperCase() + key.slice(1); // Capitalize first letter
                        const div = document.createElement('div');
                        div.className = 'quality-section-item';
                        div.innerHTML = `<span>${sectionName}</span><span>${section.score}/${section.max}</span>`;
                        this.sectionScoresDisplay.appendChild(div);
                    }
                }
            }

            /**
             * Displays the post-call summary modal with detailed quality report.
             */
            showPostCallSummary() {
                if (!this.latestQualityReport) {
                    this.addMessage('No quality report generated for this call.', 'ai');
                    return;
                }

                const report = this.latestQualityReport;
                this.modalSectionDetails.innerHTML = ''; // Clear previous content

                // Auto-fail status
                if (report.autoFailDetected) {
                    this.autoFailStatus.style.display = 'block';
                    this.autoFailReason.textContent = report.autoFailReason;
                    this.modalTotalScore.querySelector('span').textContent = '0';
                    this.modalTotalScore.querySelector('span').className = 'text-red-500';
                } else {
                    this.autoFailStatus.style.display = 'none';
                    this.modalTotalScore.querySelector('span').textContent = `${report.totalScore}`;
                    this.modalTotalScore.querySelector('span').className = 'text-blue-500';
                }

                // Detailed section breakdown
                for (const sectionKey in report.sections) {
                    if (report.sections.hasOwnProperty(sectionKey)) {
                        const section = report.sections[sectionKey];
                        const sectionTitle = sectionKey.toUpperCase(); // e.g., S1, S2, BEHAVIORS

                        const sectionDiv = document.createElement('div');
                        sectionDiv.innerHTML = `<h4 class="text-white font-semibold">${sectionTitle} (${section.score}/${section.max} points)</h4>`;
                        const ul = document.createElement('ul');

                        if (section.criteria && Array.isArray(section.criteria)) {
                            section.criteria.forEach(criterion => {
                                const li = document.createElement('li');
                                li.innerHTML = `<span>${criterion.name}</span> <span>${criterion.awardedScore}/${criterion.maxScore}</span>`;
                                ul.appendChild(li);
                            });
                        } else {
                            const li = document.createElement('li');
                            li.textContent = 'No detailed criteria available.';
                            ul.appendChild(li);
                        }
                        sectionDiv.appendChild(ul);
                        this.modalSectionDetails.appendChild(sectionDiv);
                    }
                }

                this.postCallModal.classList.add('show');
            }

            /**
             * Exports the latest quality report as a JSON file.
             */
            exportQualityReport() {
                if (!this.latestQualityReport) {
                    console.warn('No quality report to export.');
                    return;
                }
                const reportJson = JSON.stringify(this.latestQualityReport, null, 2);
                const blob = new Blob([reportJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `call_quality_report_${new Date().toISOString()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            /**
             * Starts a new role-play simulation, initializing the chat and UI.
             */
            async startNewRolePlay() {
                this.initRecognition(); // Initialize speech recognition
                this.chatDiv.innerHTML = ''; // Clear chat history display
                this.complaintsService.clearHistory(); // Clear LLM's chat history
                this.fullTranscript = []; // Clear local full transcript
                this.latestQualityReport = null; // Clear previous report
                this.displayQualityFeedback(null); // Reset quality panel

                this.updateStatus('Welcome! Click mic to start conversation.', false);

                // Initial welcome message from AI
                const welcomeMsg = "Welcome to the AI Call Simulator! To use the simulator, please ensure your browser has microphone access enabled.";
                this.addMessage(welcomeMsg, 'ai');
                await this.saveMessageToFirestore(welcomeMsg, 'ai');

                // Initial customer scenario
                const initialScenario = this.complaintsService.getInitialScenario();
                this.addMessage(`Customer: ${initialScenario}`, 'ai');
                this.fullTranscript.push({ speaker: 'ai', text: initialScenario });
                await this.saveMessageToFirestore(initialScenario, 'ai');


                // Only speak if not muted and after a small delay to ensure voices are loaded
                if (!this.isMuted) {
                    try {
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for voice loading
                        await this.speechService.speak(initialScenario);
                    } catch (err) {
                        console.error('[CallSimulator] Failed to speak initial message:', err);
                        this.addMessage('Note: Voice output failed. Please check your audio settings.', 'ai');
                    }
                }

                // Prompt user to start
                this.updateStatus('Click mic to start', false);
            }
        }

        // Initialize the simulator when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const simulator = new CallSimulator();
            simulator.startNewRolePlay();

            // Example: Show post-call summary after some interaction (you might trigger this differently)
            // setTimeout(() => {
            //     simulator.showPostCallSummary();
            // }, 10000); // For demonstration, remove in production
        });

        // Register Service Worker for PWA capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Service Worker registration failed: ', registrationError);
                    });
            });
        }
    </script>
</body>
</html>
